<!DOCTYPE HTML>
<!--
	TXT by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>hw1-2</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
	</head>
	<body class="is-preload">
		<div id="page-wrapper">

			<header id="header">
				<div class="logo container">
					<div>
						<p><a href="HCI_hw1_JisooHwang.docx" download>hw1 전체 다운로드</a></p>
					</div>
				</div>
			</header>

			<!-- Nav -->
			<nav id="nav">
				<ul>
					<li><a href="index.html">Home</a></li>
					<li><a href="hw1_1.html">hw1-1</a></li>
					<li class="current"><a href="hw1_2.html">hw1-2</a></li>
				</ul>
			</nav>

			<!-- Main -->
				<section id="main">
					<div class="container">
						<div class="row">
							<div class="col-12">
								<div class="content">

									<!-- Content -->

										<article class="box page-content">

											<header>
												<h2>2. Travel Planning websites – Airbnb.com vs Hotels.com vs Booking.com</h2>


												<ul class="meta">
													<li class="icon fa-clock-o">2018.09.18</li>
												</ul>
											</header>

											<section>
												<span class="image featured"><img src="images/trip.png" alt="" /></span>
												<p>
											세 웹사이트는 여행 서비스 분야에서 공통적으로 숙소를 예약할 수 있는 사이트들이다.
											각 사이트에서 제공하고 있는 주력 숙소의 종류는 다르며, 이에 따라 UI가 유사하지만 다르게 구성되어 있다.
											세부적으로 구분하자면, 에어비앤비(Airbnb)는 누군가의 실제 집 전체 혹은 남는 방을 예약할 수 있고,
											호텔스닷컴(hotels.com)은 이름 그대로 1~5성급의 호텔을 예약할 수 있다.
											북킹닷컴(booking.com)은 호텔스닷컴보다는 범위가 더 넓은 사이트로, 호텔뿐만 아니라 유스호스텔이나 펜션과 같은 숙박시설도 예약이 가능하다.
											여행 예산 혹은 숙소 취향에 따라서 이 사이트들 중 한 가지를 선택해서 숙박시설을 선택하게 된다.
											실제로 이번 1학기에 교환학생을 갔을 당시에 여행을 할 때 실제로 예약을 해서 사용해본 경험이 있는 사이트들이고,
											실제 경험을 대입하여 이 세 사이트를 비교 분석해보고자 한다.
												</p>

											</section>

											<section>
												<h3>세 사이트의 첫 페이지</h3>
												<p>
													시리의 실행 task model은 다음과 같다. 시리를 사용하기 전에,
													미리 자신의 목소리로 약 3번 ‘시리야’를 외치게 한 후 그 정보를 저장한다.
													이후에는 아이폰 내장 마이크를 항상 켜 놔야 하며, 아이폰이 받는 수 많은 소리 입력들 중에서
													나의 목소리인 ‘시리야’를 인식해서 자동으로 실행이 되는 것이다. 만약 음성으로 시리를 실행시키고 싶지 않으면
													 홈버튼을 1초 이상 꾹 누르면 똑같이 실행이 된다.
													 실행시키는 방법에 음성과 터치 방식을 interaction의 방식으로 설정한 것이다.
												</p>
												<p>
												이 두 가지 방식을 모두 설정해 놓은 것은 시리를 처음 사용하는 데에 있어서는 보편적인 사용성을 확보한 것이라고 생각한다.
												소리를 내는 것은 일단 눈이 불편한 사람들도 사용할 수 있게 되는 것이고, 버튼을 누르는 방식도 추가함으로써
												소리를 낼 수 없는 상황에서도 실행시킬 수 있게 되기 때문이다. 하지만 그 다음 단계인 질문을 하는 것에 있어서는
												소리를 내는 것 외에는 방법이 없기 때문에, 소리를 낼 수 없는 조용한 곳에서의 사용이나 소리를 내는 것이 힘든 사람들은
												음성을 바탕으로 작동되는 AI assistant interface에서는 배제될 수밖에 없다.
												 또한 질문의 대답으로 제공되는 정보도 약간의 청각정보와 대부분의 시각정보로 이루어지기 때문에,
												 차를 운전하는 중이거나 시각 정보를 보기가 어려운 사람들도 배제된다.즉, AI assistant가 첫 단계에서는 보편적인 사용성을 확보했을 지는
												 몰라도 이후의 일련의 단계에서는 기술을 더 추가하거나 더 다양한 사용 상황을 고려해야 할 필요성이 있다.
												</p>
												<p>
												또한 새로운 질문으로의 전환이 불편하다. 물론 재질문을 할 때는 첫 질문과 똑같이 음성이나 터치를 하는 방식을 취하고 있지만,
												사용자들이 평균적으로 몇 개의 질문을 하는 지를 생각해본다면 매 질문 마다 사용자가 시리를 실행시키게 만드는 것이 아닌,
												기본적으로 2-3개 정도 시리가 질문을 연속적으로 받을 수 있도록 설정할 필요가 있다고 생각한다.
												현재 시리는 완벽하지 않다 보니 하나의 원하는 것을 얻기 위해 여러 번 질문하게 되는데,
												그때마다 시리를 외치거나 버튼을 꾹 눌러서 다시 인식될 때까지 기다리는 시간이 사용자 경험 측면에서 길며 비효율적이다.
												연속적으로 질문을 처리할 수 있도록 만든다면 굳이 저 방식을 매순간 반복할 필요가 없기 때문이다.
												</p>
												<p>
												더 구체적으로 분석해보면, 예를 들어 이탈리아 로마에 10월 17일부터 21일까지 2명이서 여행을 간다고 가정을 해보자.
												첫 화면에 이러한 여행 정보를 입력할 것이다. 여기서 작은 디테일을 비교해보면, 기본적으로 모두 여행 인원은 2명이라고 설정이 되어 있으며,
												나의 검색 기록에 맞춰서 그 설정은 바뀌게 된다. 하지만 에어비앤비와 부킹닷컴은 여행 기간을 설정함에 있어서 체크인 날짜 설정 버튼을 누르고,
												달력에서 시작 일자와 마지막 일자를 클릭하면 체크인 날짜 버튼을 눌렀더라도 체크아웃 날짜가 입력한 마지막 일자로 자동 설정이 된다.
												 하지만 호텔스닷컴은 이것이 자동적으로 설정이 되지 않고 버튼을 두 번 눌러야 한다. 즉, 여행 기간을 설정함에 있어서 두 사이트는
												 총 세번의 클릭을 하면 되지만, 호텔스닷컴은 네 번의 클릭을 하게 하는 것이다. 정보 입력 단계에서는 에어비앤비와 부킹닷컴이
												 호텔스닷컴보다 interaction model의 사용성이 떨어진다고 볼 수 있다.
												</p>

											</section>

											<section>
												<h3>로마에 있는 숙소를 찾는다면?</h3>
												<p>
												이제 정보를 입력을 한 후에는 이 기간동안 예약이 가능한 숙소들의 정보를 각각의 UI로 다르게 제공한다. 아래는 위 가정을 동일하게 입력한 결과
												페이지이다. 순차적으로 에어비앤비, 호텔스닷컴, 부킹닷컴 순이다.
												</p>
												<p>
												이 페이지들을 보면 공통적으로 사람들이 조급함을 갖고 예약을 빠르게 결정하게 하기 위해 몇 명의 사람들이 보고 있는지,
												특가 할인의 마감이 언제인지 등에 대한 정보를 나타내고 있다. 에어비앤비는 필터 탭 아래에서만 몇 명이 보고 있는지에 대한 정보를 나타낸다.
												북킹닷컴은 예약이 빨리 마감되는 것이 무엇인지 빨간색으로 표시하고, 예약이 다 찬 숙소를 삭제하지 않고 몇 시간 전에 예약이 마감되었는지 나타내며
												 사용자의 조급함을 이끌어 내려고 하고 있다. 호텔스닷컴도 북킹닷컴과 비슷하지만 한 가지 다른 점은 동적인 팝업을 쓰고 있다는 것이다.
												 하단 아래에서 계속 몇 명이 보고 있고, 최근 몇 분 전에 어디가 예약이 되었다는 메시지를 계속 띄운다. 이미 가운데 상단에 정보가 많은 상황에서
												 동적으로 움직이는 팝업까지 있으니 사용자가 어수선하게 느끼며 피곤함을 느끼게 될 가능성이 높다. 또한 필터가 단순한 에어비앤비와 달리 호텔스닷컴과
												  북킹닷컴은 상단 탭에도 필터가 있고 왼쪽 바에 스크롤을 두 세번 내려도 다 보지 못할 정도의 필터들을 나열하고 있다. 이는 페이지 안에
													정보들이 과도하게 많아 오랜 시간 머물며 검색을 하기가 피곤하다. 페이지 자체가 구조화가 되어 있어 비교하기 쉽긴 하지만,
													복잡한 정보들이 모든 화면에 꽉 차게 들어 있기 때문에 좀 더 최적화된 페이지 구성이 필요하다고 생각한다.
												</p>
											</section>

										</article>

								</div>
							</div>

						</div>
					</div>
				</section>

			<!-- Footer -->
				<footer id="footer">
					<div class="container">


						<!-- Copyright -->
							<div id="copyright">
								<ul class="menu">
									<li>&copy; JisooHwang. All rights reserved</li>
							</div>

					</div>
				</footer>

		</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.dropotron.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
